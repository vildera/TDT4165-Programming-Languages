
==================== FINAL INTERFACE ====================
2018-09-19 12:08:51.353059 UTC

interface ex3code-0.1.0.0-6rUj3bfK7Y5I8oTjgnWRc3:Lib 8022
  interface hash: 9958defee00c52e98f1fe7a65c7631bd
  ABI hash: 621d885ecb9b63766096ae30f98c8dbb
  export-list hash: 33edac3077f1b5c9ba19f49d8eb8388e
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 0451a77cc0d8e5d99d548d6441c7dd35
  sig of: Nothing
  used TH splices: False
  where
exports:
  Lib.all
  Lib.any
  Lib.concat
  Lib.elem
  Lib.length
  Lib.listConcat
  Lib.listMaximum
  Lib.listMinimum
  Lib.listProduct
  Lib.listSum
  Lib.safeMaximum
  Lib.safeMinimum
  Lib.sum
  Lib.Complex{Lib.Complex}
  Lib.Foldable|{Lib.foldr}
module dependencies:
package dependencies: base-4.10.1.0* ghc-prim-0.5.1.1
                      integer-gmp-1.0.1.0
orphans: base-4.10.1.0:GHC.Float base-4.10.1.0:GHC.Base
family instance modules: base-4.10.1.0:Control.Applicative
                         base-4.10.1.0:Data.Either base-4.10.1.0:Data.Functor.Const
                         base-4.10.1.0:Data.Functor.Identity base-4.10.1.0:Data.Monoid
                         base-4.10.1.0:Data.Type.Equality base-4.10.1.0:GHC.Generics
                         base-4.10.1.0:GHC.IO.Exception base-4.10.1.0:GHC.TypeLits
                         base-4.10.1.0:GHC.TypeNats
import  -/  base-4.10.1.0:GHC.Base 782fd99b5e36f3698a26179a49afca64
import  -/  base-4.10.1.0:GHC.Float 28e3bf9e258278ac8084e9cab43fd542
import  -/  base-4.10.1.0:GHC.Num 6e1dc5d36d99a802edb39b92bb1923b8
import  -/  base-4.10.1.0:GHC.Real 3c62834bc25e762eabc44149c4cc142d
import  -/  base-4.10.1.0:GHC.Show 0a8ce2b5e533d1c2cfb7954e6736be45
import  -/  base-4.10.1.0:Prelude 31945b7d0084063347fc52506d3a4020
import  -/  ghc-prim-0.5.1.1:GHC.Classes 93e2660065dce9329577e83d76d8f0d4
63e079d5d0a2f4e8a7dab8d448b7f95f
  $fEqComplex :: GHC.Classes.Eq Lib.Complex
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Lib.Complex Lib.$fEqComplex_$c== Lib.$fEqComplex_$c/= -}
63e079d5d0a2f4e8a7dab8d448b7f95f
  $fEqComplex_$c/= :: Lib.Complex -> Lib.Complex -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S)L),1*U(1*U(U),1*U(U))><S(S(S)L),1*U(1*U(U),1*U(U))>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Lib.Complex) (w1 :: Lib.Complex) ->
                 case w of ww { Lib.Complex ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.D# ww4 ->
                 case w1 of ww5 { Lib.Complex ww6 ww7 ->
                 case ww6 of ww8 { GHC.Types.D# ww9 ->
                 Lib.$w$c/= ww4 ww2 ww9 ww7 } } } }) -}
63e079d5d0a2f4e8a7dab8d448b7f95f
  $fEqComplex_$c== :: Lib.Complex -> Lib.Complex -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S)L),1*U(1*U(U),1*U(U))><S(S(S)L),1*U(1*U(U),1*U(U))>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Lib.Complex) (w1 :: Lib.Complex) ->
                 case w of ww { Lib.Complex ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.D# ww4 ->
                 case w1 of ww5 { Lib.Complex ww6 ww7 ->
                 case ww6 of ww8 { GHC.Types.D# ww9 ->
                 Lib.$w$c== ww4 ww2 ww9 ww7 } } } }) -}
ae656bd7ccd3457b59d99fca1284fe60
  $fFoldable[] :: Lib.Foldable []
  DFunId
  {- Arity: 3, HasNoCafRefs, Strictness: <L,C(C1(U))><L,1*U><S,1*U>,
     Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Lib.$fFoldable[]_$cfoldr `cast` (Sym (Lib.N:Foldable[0] <[]>_N)) -}
f8f080e7baa4f07c8d9db81440bb17cd
  $fFoldable[]_$cfoldr :: (a -> b -> b) -> b -> [a] -> b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,C(C1(U))><L,1*U><S,1*U> -}
63e079d5d0a2f4e8a7dab8d448b7f95f
  $fNumComplex :: GHC.Num.Num Lib.Complex
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Lib.Complex
                  Lib.$fNumComplex_$c+
                  Lib.$fNumComplex_$c-
                  Lib.$fNumComplex_$c*
                  Lib.$fNumComplex_$cnegate
                  Lib.$fNumComplex_$cabs
                  Lib.$fNumComplex_$csignum
                  Lib.$fNumComplex_$cfromInteger -}
94b90bc02697097aaa0b3b8cb4c435ed
  $fNumComplex1 :: GHC.Types.Double
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.D# 0.0##) -}
63e079d5d0a2f4e8a7dab8d448b7f95f
  $fNumComplex_$c* :: Lib.Complex -> Lib.Complex -> Lib.Complex
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U(U(U),U(U))><S,1*U(U(U),U(U))>m, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Lib.Complex) (w1 :: Lib.Complex) ->
                 case w of ww { Lib.Complex ww1 ww2 ->
                 case w1 of ww3 { Lib.Complex ww4 ww5 ->
                 Lib.Complex
                   (case ww1 of wild2 { GHC.Types.D# x ->
                    case ww4 of wild3 { GHC.Types.D# y ->
                    case ww2 of wild1 { GHC.Types.D# x1 ->
                    case ww5 of wild5 { GHC.Types.D# y1 ->
                    GHC.Types.D#
                      (GHC.Prim.-## (GHC.Prim.*## x y) (GHC.Prim.*## x1 y1)) } } } })
                   (case ww1 of wild2 { GHC.Types.D# x ->
                    case ww5 of wild3 { GHC.Types.D# y ->
                    case ww2 of wild1 { GHC.Types.D# x1 ->
                    case ww4 of wild5 { GHC.Types.D# y1 ->
                    GHC.Types.D#
                      (GHC.Prim.+##
                         (GHC.Prim.*## x y)
                         (GHC.Prim.*## x1 y1)) } } } }) } }) -}
63e079d5d0a2f4e8a7dab8d448b7f95f
  $fNumComplex_$c+ :: Lib.Complex -> Lib.Complex -> Lib.Complex
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U(1*U(U),1*U(U))><S,1*U(1*U(U),1*U(U))>m,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Lib.Complex) (ds1 :: Lib.Complex) ->
                 case ds of wild { Lib.Complex a b ->
                 case ds1 of wild1 { Lib.Complex c d ->
                 Lib.Complex
                   (GHC.Float.plusDouble a c)
                   (GHC.Float.plusDouble b d) } }) -}
63e079d5d0a2f4e8a7dab8d448b7f95f
  $fNumComplex_$c- :: Lib.Complex -> Lib.Complex -> Lib.Complex
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U(1*U(U),1*U(U))><S,1*U(1*U(U),1*U(U))>m,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Lib.Complex) (ds1 :: Lib.Complex) ->
                 case ds of wild { Lib.Complex a b ->
                 case ds1 of wild1 { Lib.Complex c d ->
                 Lib.Complex
                   (GHC.Float.minusDouble a c)
                   (GHC.Float.minusDouble b d) } }) -}
63e079d5d0a2f4e8a7dab8d448b7f95f
  $fNumComplex_$cabs :: Lib.Complex -> Lib.Complex
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(1*U(U),1*U(U))>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Lib.Complex) ->
                 case ds of wild { Lib.Complex a b ->
                 Lib.Complex
                   (case a of wild2 { GHC.Types.D# x ->
                    case b of wild1 { GHC.Types.D# x1 ->
                    GHC.Types.D#
                      (GHC.Prim.sqrtDouble#
                         (GHC.Prim.+##
                            (GHC.Prim.**## x 2.0##)
                            (GHC.Prim.**## x1 2.0##))) } })
                   Lib.$fNumComplex1 }) -}
63e079d5d0a2f4e8a7dab8d448b7f95f
  $fNumComplex_$cfromInteger ::
    GHC.Integer.Type.Integer -> Lib.Complex
  {- Arity: 1, HasNoCafRefs, Strictness: <L,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ (n :: GHC.Integer.Type.Integer) ->
                 Lib.Complex
                   (GHC.Float.$fNumDouble_$cfromInteger n)
                   Lib.$fNumComplex1) -}
63e079d5d0a2f4e8a7dab8d448b7f95f
  $fNumComplex_$cnegate :: Lib.Complex -> Lib.Complex
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(1*U(U),1*U(U))>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Lib.Complex) ->
                 case ds of wild { Lib.Complex a b ->
                 Lib.Complex
                   (GHC.Float.negateDouble a)
                   (GHC.Float.negateDouble b) }) -}
63e079d5d0a2f4e8a7dab8d448b7f95f
  $fNumComplex_$csignum :: Lib.Complex -> Lib.Complex
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U(U),U(U))>m,
     Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Lib.Complex) ->
                 case w of ww { Lib.Complex ww1 ww2 ->
                 let {
                   length3 :: GHC.Types.Double
                   = case ww1 of wild2 { GHC.Types.D# x ->
                     case ww2 of wild1 { GHC.Types.D# x1 ->
                     GHC.Types.D#
                       (GHC.Prim.sqrtDouble#
                          (GHC.Prim.+##
                             (GHC.Prim.**## x 2.0##)
                             (GHC.Prim.**## x1 2.0##))) } }
                 } in
                 Lib.Complex
                   (GHC.Float.divideDouble ww1 length3)
                   (GHC.Float.divideDouble ww2 length3) }) -}
63e079d5d0a2f4e8a7dab8d448b7f95f
  $fShowComplex :: GHC.Show.Show Lib.Complex
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Lib.Complex
                  Lib.$fShowComplex_$cshowsPrec
                  Lib.$fShowComplex_$cshow
                  Lib.$fShowComplex_$cshowList -}
63e079d5d0a2f4e8a7dab8d448b7f95f
  $fShowComplex1 ::
    Lib.Complex -> GHC.Base.String -> [GHC.Types.Char]
  {- Arity: 2, Strictness: <S(S(S)S(S)),1*U(1*U(U),1*U(U))><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Lib.Complex) (s :: GHC.Base.String)[OneShot] ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b
                      (c :: GHC.Types.Char -> b -> b)[OneShot]
                      (n :: b)[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b
                      c
                      n
                      (Lib.$fShowComplex_$cshow x))
                   s) -}
1e3cd00ec632fa99cd96f52ab3de6a3c
  $fShowComplex2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("+"#) -}
3b40c4e904b8e58be5f3b04468601c79
  $fShowComplex3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Lib.$fShowComplex4) -}
cb3c8c1d3771f066dc61a7033b6a902e
  $fShowComplex4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("i"#) -}
d9ffa6b7b9c0462fcccac3c664aa3b58
  $fShowComplex5 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("-"#) -}
63e079d5d0a2f4e8a7dab8d448b7f95f
  $fShowComplex_$cshow :: Lib.Complex -> GHC.Base.String
  {- Arity: 1, Strictness: <S(S(S)S(S)),1*U(1*U(U),1*U(U))>,
     Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Lib.Complex) ->
                 case w of ww { Lib.Complex ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.D# ww4 ->
                 case ww2 of ww5 { GHC.Types.D# ww6 ->
                 Lib.$w$cshow ww4 ww6 } } }) -}
63e079d5d0a2f4e8a7dab8d448b7f95f
  $fShowComplex_$cshowList :: [Lib.Complex] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [Lib.Complex]) (s :: GHC.Base.String) ->
                 GHC.Show.showList__ @ Lib.Complex Lib.$fShowComplex1 ls s) -}
63e079d5d0a2f4e8a7dab8d448b7f95f
  $fShowComplex_$cshowsPrec ::
    GHC.Types.Int -> Lib.Complex -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,A><S(S(S)S(S)),1*U(1*U(U),1*U(U))><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ds :: GHC.Types.Int)
                   (x :: Lib.Complex)
                   (s :: GHC.Base.String) ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b
                      (c :: GHC.Types.Char -> b -> b)[OneShot]
                      (n :: b)[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b
                      c
                      n
                      (Lib.$fShowComplex_$cshow x))
                   s) -}
c700347eafc9b0e61f819ad3ef489eb8
  $tc'Complex :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8900275939469358489##
                   706514092414566531##
                   Lib.$trModule
                   Lib.$tc'Complex2
                   0#
                   Lib.$tc'Complex1) -}
373361c2a14b322da6f2ccf102a63623
  $tc'Complex1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
ad9a6a598b64454e44a60119df3301ab
  $tc'Complex2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Lib.$tc'Complex3) -}
9ea0f4c67bf353fe61e50643bab4e03d
  $tc'Complex3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Complex"#) -}
240e9acadf45bcc1cf4b158269b8dedb
  $tcComplex :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   18183195364161405907##
                   13162338269498061864##
                   Lib.$trModule
                   Lib.$tcComplex1
                   0#
                   GHC.Types.krep$*) -}
753501acdbb09f71ce3ac016a4ad4b45
  $tcComplex1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Lib.$tcComplex2) -}
b5b622fbe3bc64752f05397f9cc23a0f
  $tcComplex2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Complex"#) -}
727fb6dcbcc336054843f57b8c8edd48
  $tcFoldable :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9808329068399644966##
                   16835164831528319984##
                   Lib.$trModule
                   Lib.$tcFoldable2
                   0#
                   Lib.$tcFoldable1) -}
1b9c86da9b777545766308110f73882e
  $tcFoldable1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
b6dc6a790637fded914aa29cc743a2fa
  $tcFoldable2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Lib.$tcFoldable3) -}
46b0172762fee24cd0129aa597eda3bb
  $tcFoldable3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Foldable"#) -}
e0aebfaa0f4e015e76f018ca4952a471
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Lib.$trModule3 Lib.$trModule1) -}
4a5f807290765ca326c33b4fa2f45a60
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Lib.$trModule2) -}
48f546541942805ff643cccd72f56af1
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Lib"#) -}
380b1a7c6b4f773df24a7c12f10c1717
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Lib.$trModule4) -}
c13f46b7e5fc75be17327105234c2d69
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("ex3code-0.1.0.0-6rUj3bfK7Y5I8oTjgnWRc3"#) -}
4c255126c636062382ab50085e92f4e8
  $w$c/= ::
    GHC.Prim.Double#
    -> GHC.Types.Double
    -> GHC.Prim.Double#
    -> GHC.Types.Double
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S,U><L,1*U(U)><S,U><L,1*U(U)>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Double#)
                   (ww1 :: GHC.Types.Double)
                   (ww2 :: GHC.Prim.Double#)
                   (ww3 :: GHC.Types.Double) ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.==## ww ww2) of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True
                   -> case ww1 of wild1 { GHC.Types.D# x ->
                      case ww3 of wild2 { GHC.Types.D# y ->
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==## x y) of wild3 {
                        GHC.Types.False -> GHC.Types.True
                        GHC.Types.True -> GHC.Types.False } } } }) -}
1f0701c2871cee95255ef8071a1c7291
  $w$c== ::
    GHC.Prim.Double#
    -> GHC.Types.Double
    -> GHC.Prim.Double#
    -> GHC.Types.Double
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S,U><L,1*U(U)><S,U><L,1*U(U)>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Double#)
                   (ww1 :: GHC.Types.Double)
                   (ww2 :: GHC.Prim.Double#)
                   (ww3 :: GHC.Types.Double) ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.==## ww ww2) of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True -> GHC.Classes.eqDouble ww1 ww3 }) -}
dba22a292fef7bb4eb5b06adbde3b74d
  $w$cshow :: GHC.Prim.Double# -> GHC.Prim.Double# -> GHC.Base.String
  {- Arity: 2, Strictness: <S,U><S,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Double#) (ww1 :: GHC.Prim.Double#) ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=## ww1 0.0##) of wild {
                   GHC.Types.False
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        (GHC.Float.$w$sshowSignedFloat
                           GHC.Float.$fShowDouble2
                           GHC.Float.minExpt
                           ww
                           (GHC.Types.[] @ GHC.Types.Char))
                        (GHC.CString.unpackAppendCString#
                           Lib.$fShowComplex5
                           (GHC.Base.++
                              @ GHC.Types.Char
                              (GHC.Float.$w$sshowSignedFloat
                                 GHC.Float.$fShowDouble2
                                 GHC.Float.minExpt
                                 (GHC.Prim.fabsDouble# ww1)
                                 (GHC.Types.[] @ GHC.Types.Char))
                              Lib.$fShowComplex3))
                   GHC.Types.True
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        (GHC.Float.$w$sshowSignedFloat
                           GHC.Float.$fShowDouble2
                           GHC.Float.minExpt
                           ww
                           (GHC.Types.[] @ GHC.Types.Char))
                        (GHC.CString.unpackAppendCString#
                           Lib.$fShowComplex2
                           (GHC.Base.++
                              @ GHC.Types.Char
                              (GHC.Float.$w$sshowSignedFloat
                                 GHC.Float.$fShowDouble2
                                 GHC.Float.minExpt
                                 ww1
                                 (GHC.Types.[] @ GHC.Types.Char))
                              Lib.$fShowComplex3)) }) -}
63e079d5d0a2f4e8a7dab8d448b7f95f
  data Complex = Complex GHC.Types.Double GHC.Types.Double
ae656bd7ccd3457b59d99fca1284fe60
  class Foldable (t :: * -> *) where
    foldr :: (a -> b -> b) -> b -> t a -> b
    {-# MINIMAL foldr #-}
e3a5601b34b67d0c7daacca9e8baae61
  all ::
    Lib.Foldable t => (a -> GHC.Types.Bool) -> t a -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <C(C(S)),1*C1(C1(U))><L,C(U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ t :: * -> *
                   @ a
                   ($dFoldable :: Lib.Foldable t)
                   (predicate :: a -> GHC.Types.Bool) ->
                 $dFoldable `cast` (Lib.N:Foldable[0] <t>_N)
                   @ a
                   @ GHC.Types.Bool
                   (\ (x :: a) (a1 :: GHC.Types.Bool) ->
                    case predicate x of wild {
                      GHC.Types.False -> GHC.Types.False GHC.Types.True -> a1 })
                   GHC.Types.True) -}
79b5eb140ce1d7c10116ab2b0fea74c8
  any ::
    Lib.Foldable t => (a -> GHC.Types.Bool) -> t a -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <C(C(S)),1*C1(C1(U))><L,C(U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ t :: * -> *
                   @ a
                   ($dFoldable :: Lib.Foldable t)
                   (predicate :: a -> GHC.Types.Bool) ->
                 $dFoldable `cast` (Lib.N:Foldable[0] <t>_N)
                   @ a
                   @ GHC.Types.Bool
                   (\ (x :: a) (a1 :: GHC.Types.Bool) ->
                    case predicate x of wild {
                      GHC.Types.False -> a1 GHC.Types.True -> GHC.Types.True })
                   GHC.Types.False) -}
59f58f8242f07c411f42d80c91f07b5b
  concat :: Lib.Foldable t => t [a] -> [a]
  {- Arity: 1, HasNoCafRefs, Strictness: <C(C(S)),1*C1(C1(U))>,
     Unfolding: InlineRule (1, True, False)
                (\ @ t :: * -> * @ a ($dFoldable :: Lib.Foldable t) ->
                 $dFoldable `cast` (Lib.N:Foldable[0] <t>_N)
                   @ [a]
                   @ [a]
                   (GHC.Base.++ @ a)
                   (GHC.Types.[] @ a)) -}
ca57b4da1e5638c206329539b5553efb
  elem ::
    (GHC.Classes.Eq a, Lib.Foldable t) => a -> t a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><C(C(S)),1*C1(C1(U))><L,U>,
     Unfolding: (\ @ a
                   @ t :: * -> *
                   ($dEq :: GHC.Classes.Eq a)
                   ($dFoldable :: Lib.Foldable t)
                   (element :: a) ->
                 $dFoldable `cast` (Lib.N:Foldable[0] <t>_N)
                   @ a
                   @ GHC.Types.Bool
                   (\ (x :: a) (a1 :: GHC.Types.Bool) ->
                    case GHC.Classes.== @ a $dEq x element of wild {
                      GHC.Types.False -> a1 GHC.Types.True -> GHC.Types.True })
                   GHC.Types.False) -}
099dbaae51e333d0600cff3920b0080f
  length :: Lib.Foldable t => t a -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <C(C(S)),1*C1(C1(U))>,
     Unfolding: InlineRule (1, True, False)
                (\ @ t :: * -> * @ a ($dFoldable :: Lib.Foldable t) ->
                 $dFoldable `cast` (Lib.N:Foldable[0] <t>_N)
                   @ a
                   @ GHC.Types.Int
                   (Lib.length2 @ a)
                   Lib.length1) -}
e943b9a398697630e4b74d142f745052
  length1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
d23ec0ed97e3018d4758ce0d8996daf1
  length2 :: a -> GHC.Types.Int -> GHC.Types.Int
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><S(S),1*U(U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a (ds :: a) (acc :: GHC.Types.Int) ->
                 case acc of wild { GHC.Types.I# x ->
                 GHC.Types.I# (GHC.Prim.+# x 1#) }) -}
0ee7b459d316f31752cb17af572cc191
  listConcat :: [[a]] -> [a]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
ced710caf250ae3b5ea7664608a98a1e
  listMaximum :: GHC.Classes.Ord a => [a] -> GHC.Base.Maybe a
  {- Arity: 2, Strictness: <L,U(A,A,A,A,A,C(C1(U)),A,A)><S,1*U> -}
4add18586319f1042e5aa86fbb5ec545
  listMinimum :: GHC.Classes.Ord a => [a] -> GHC.Base.Maybe a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,A,C(C1(U)),A,A,A,A)><S,1*U> -}
d60098091b2ec76449fafc603aee96dc
  listProduct :: GHC.Num.Num a => [a] -> a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,U(A,A,C(C1(U)),A,A,A,C(U))><S,1*U> -}
8d190cf5d997a4ab6fe0bb5d921e32c7
  listSum :: GHC.Num.Num a => [a] -> a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,U(C(C1(U)),A,A,A,A,A,C(U))><S,1*U> -}
8f8dc85a2c13255e91b50fb4afda2dfa
  safeMaximum ::
    (Lib.Foldable t, GHC.Classes.Ord a) => t a -> GHC.Base.Maybe a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <C(C(S)),1*C1(C1(U))><L,U(A,A,A,A,A,C(C1(U)),A,A)>,
     Unfolding: (\ @ t :: * -> *
                   @ a
                   ($dFoldable :: Lib.Foldable t)
                   ($dOrd :: GHC.Classes.Ord a) ->
                 $dFoldable `cast` (Lib.N:Foldable[0] <t>_N)
                   @ a
                   @ (GHC.Base.Maybe a)
                   (\ (x :: a) (ds :: GHC.Base.Maybe a) ->
                    case ds of wild {
                      GHC.Base.Nothing -> GHC.Base.Just @ a x
                      GHC.Base.Just y
                      -> case GHC.Classes.>= @ a $dOrd x y of wild1 {
                           GHC.Types.False -> wild GHC.Types.True -> GHC.Base.Just @ a x } })
                   (GHC.Base.Nothing @ a)) -}
666acf68755c5a44161689eca86825a3
  safeMinimum ::
    (Lib.Foldable t, GHC.Classes.Ord a) => t a -> GHC.Base.Maybe a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <C(C(S)),1*C1(C1(U))><L,U(A,A,A,C(C1(U)),A,A,A,A)>,
     Unfolding: (\ @ t :: * -> *
                   @ a
                   ($dFoldable :: Lib.Foldable t)
                   ($dOrd :: GHC.Classes.Ord a) ->
                 $dFoldable `cast` (Lib.N:Foldable[0] <t>_N)
                   @ a
                   @ (GHC.Base.Maybe a)
                   (\ (x :: a) (ds :: GHC.Base.Maybe a) ->
                    case ds of wild {
                      GHC.Base.Nothing -> GHC.Base.Just @ a x
                      GHC.Base.Just y
                      -> case GHC.Classes.<= @ a $dOrd x y of wild1 {
                           GHC.Types.False -> wild GHC.Types.True -> GHC.Base.Just @ a x } })
                   (GHC.Base.Nothing @ a)) -}
13e5c9dea13ad0b0679c13ffa2ac5acd
  sum :: (GHC.Num.Num a, Lib.Foldable t) => t a -> a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(1*U,A,A,A,A,A,1*C1(U))><C(C(S)),1*C1(C1(U))>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ t :: * -> *
                   ($dNum :: GHC.Num.Num a)
                   ($dFoldable :: Lib.Foldable t) ->
                 $dFoldable `cast` (Lib.N:Foldable[0] <t>_N)
                   @ a
                   @ a
                   (GHC.Num.+ @ a $dNum)
                   (GHC.Num.fromInteger @ a $dNum Lib.sum1)) -}
6926ff3b242ded4ccbc7fef4e9afaec8
  sum1 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (0) -}
instance [safe] GHC.Classes.Eq [Lib.Complex] = Lib.$fEqComplex
instance [safe] Lib.Foldable [[]] = Lib.$fFoldable[]
instance [safe] GHC.Num.Num [Lib.Complex] = Lib.$fNumComplex
instance [safe] GHC.Show.Show [Lib.Complex] = Lib.$fShowComplex
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

